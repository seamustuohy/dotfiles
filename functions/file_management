
####################################
# Movement
####################################


# Terminal and Navigation
# Alias' for easier navigation

alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias cd=cd_func


# Allow xargs to use aliased commands
# Adding a trailing space to the command being aliased causes other aliased commands to expand:
alias xargs='xargs '


# cd function for providing easy movement and history.


cd_func ()
{
  local x2 the_new_dir adir index
  local -i cnt

  if [[ $1 ==  "--" ]]; then
    dirs -v
    return 0
  fi

  the_new_dir=$1
  [[ -z $1 ]] && the_new_dir=$HOME

  if [[ ${the_new_dir:0:1} == '-' ]]; then
    #
    # Extract dir N from dirs
    index=${the_new_dir:1}
    [[ -z $index ]] && index=1
    adir=$(dirs +$index)
    [[ -z $adir ]] && return 1
    the_new_dir=$adir
  fi

  # '~' has to be substituted by ${HOME}
  [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

  # Now change to the new dir and add to the top of the stack
  pushd "${the_new_dir}" > /dev/null
  [[ $? -ne 0 ]] && return 1
  the_new_dir=$(pwd)

  # Trim down everything beyond 11th entry
  popd -n +11 2>/dev/null 1>/dev/null

  # Remove any other occurence of this dir, skipping the top of the stack
  for ((cnt=1; cnt <= 10; cnt++)); do
    x2=$(dirs +${cnt} 2>/dev/null)
    [[ $? -ne 0 ]] && return 0
    [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
    if [[ "${x2}" == "${the_new_dir}" ]]; then
      popd -n +$cnt 2>/dev/null 1>/dev/null
      cnt=cnt-1
    fi
  done

  return 0
}


####################################
# Recovering Files
####################################


# Un-delete File
undel_func(){
        local string="$1"
        # Device: i.e. /dev/sda
        local device="$2"
        echo "Searching for deleted file with string $1"
        # *"Attempt"* to recover an accidentally removed file.
        sudo fgrep --binary-files=text -C 2000 "${string}" "${device}" > recovereddata.out
}
alias undelete=undel_func


# recover deleted media files from external device
# repair mp4's on that device
undel_media() {
    #sudo foremost -i /dev/sdd1 -o ~/temp/media
    local INPUT="$1"
    local OUTPUT_PATH="$2"
    sudo foremost -i ${INPUT} -o ${OUTPUT_PATH}
    sudo chown -R s2e ${OUTPUT_PATH}
    cd ${OUTPUT_PATH}/mp4
    # Repair all mp4's found
    find . |grep xargs -I % ffmpg -i % -o %.new.mp4
    # TODO - Run repair function on all media
}

####################################
# Extracting Compressed Files
####################################



# Extract a compressed file
extract() {
        if [ -f $1 ] ; then
                case $1 in
                        *.tar.bz2) tar xvjf $1 ;;
                        *.tar.gz) tar xvzf $1 ;;
                        *.tar.xz) tar xvJf $1 ;;
                        *.xz) unxz -v $1 ;;
                        *.bz2) bunzip2 $1 ;;
                        *.rar) unrar x $1 ;;
                        *.gz) gunzip $1 ;;
                        *.tar) tar xvf $1 ;;
                        *.tbz2) tar xvjf $1 ;;
                        *.tgz) tar xvzf $1 ;;
                        *.zip) unzip $1 ;;
                        *.Z) uncompress $1;;
                        *.7z) 7z x $1 ;;
                        *) echo "'$1' cannot be extracted via >extract<" ;;
                esac
        else
                echo "'$1' is not a valid file"
        fi
}


unzip_long_name() {
    ZIPFILE="$1"
    LONG_NAME="$2"

    long_fname=${LONG_NAME%.*}
    unzip -p -j -c "$ZIPFILE" "$LONG_NAME" > "${long_fname:0:250}.${LONG_NAME##*.}"
}

unzip_all_long_names() {
    zipinfo -2 "$1" | while read i;
    do
        long_fname=${i%.*}
        unzip -p -j -c "$1" "$i" > "${long_fname:0:250}.${i##*.}"
    done;
}


# Compare original and gzipped file size
function gzip_compare() {
        local origsize=$(wc -c < "$1");
        local gzipsize=$(gzip -c "$1" | wc -c);
        local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
        printf "orig: %d bytes\n" "$origsize";
        printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}


####################################
# Metadata of files
####################################


# Nuke All Metadata
nuke_all_metadata() {
    while true; do
        echo "This will erase the metadata from all files with extensions found in this folder."
        read -p "Do you really want to run this script? [y/n]" yn
        case $yn in
            [Yy]* ) local NUKEIT="true"; break;;
            [Nn]* ) local NUKEIT="NO";  break;;
            * ) echo "Please answer yes or no.";;
        esac
    done
    if [[ "${NUKEIT}" == "true" ]]; then
        for i in *.*;
        do echo "Nuking metadata for $i";
           exiftool -all= "$i";
        done
    fi
}



# find . | xargs -I % exiftool -all= "%"
alias exiftool_nuke_all_metadata=nuke_all_metadata


####################################
# Moving Files
####################################

# DD-Status

# Get the status of a currently running dd process
# Use in a terminal NOT running the current dd! (Because that's not possible)
# Usage: ddstat
#alias ddstat="sudo kill -USR1 `pgrep -l '^dd$' | cut -f 1 -d \" \"`"
alias ddstat="sudo progress -m"

# Sync Status
alias syncstat="watch -d grep -e Dirty: -e Writeback: /proc/meminfo"

dd_progress() {
    # Use DD in a way that makes it provide useful progress information.

    # https://unix.stackexchange.com/questions/379947/how-to-prevent-dds-progress-from-being-meaningless-on-linux
    # https://stackoverflow.com/questions/33485108/why-is-dd-with-the-direct-o-direct-flag-so-dramatically-faster
    # https://www.ukuug.org/events/linux2001/papers/html/aarcangeli-o_direct.html
    # https://www.linux.co.cr/free-unix-os/review/acrobat/011207.pdf
    IF="$1"
    OF="$2"
    IS_GNOME_TERMINAL="$([[ $(basename $(ps -p $(ps -p $$ -o ppid=) -o cmd=)) == gnome-terminal* ]] && echo 'TRUE' || echo 'FALSE')"
    if [[ "${IS_GNOME_TERMINAL}" == "TRUE" ]]; then
        gnome-terminal --tab --  sudo progress -m
        # TODO: One day figure out how to use `/sys/block/[OUTPUT DEVICE NAME i.e. sdb]/queue/optimal_io_size` to determine the best large block size.
        dd if="${IF}" of="${OF}" oflag=direct bs=4M status=progress conv=fsync
        echo "Completed Transfer"
    else
        echo "In a different terminal you should run `ddstat` to see the progress of this dd command"
        dd if="${IF}" of="${OF}" oflag=direct bs=4M status=progress conv=fsync
        echo "Completed Transfer"
    fi
}

# Burn USB with alert
burnusb() {
        sudo dd if=$1 of=$2 bs=4M conv=sync
        sync
        ding
        notify-send -u critical 'burnusb' 'done'
}

shorten_all_filenames_sloppily_and_recursively() {
find . -type f -name '???????????????????????????????????????????????????????????????????????????????????????????????????????????*' -exec sh -c 'file="{}"; bn=$(basename "${file}"); dn=$(dirname "${file}"); mv -ni "${file}" "${dn}/$(echo ${bn} | cut -c1-50 | tr -d [:punct:]  )-$(uuidgen | cut -c1-8).$(echo ${bn##*.}| cut -c1-4)"' \;

}


####################################
# Compare contents of two folders
####################################

compare_folder_contents() {
    comm -3 <(ls -1 "$1" ) <(ls -1 "$2" )
}

compare_folder_contents_recursive() {
    comm -3 <(tree --noreport -I ".git" -ia "$1" | sort ) <(tree --noreport -I ".git" -ai "$2" | sort )
}

filename_does_not_exist_in_directory_recursive() {
    local PATH="$1"
    local FILENAME="$2"
    # echo "${PATH}" "${FILENAME}"
    /usr/bin/find "${PATH}" -type f -name "${FILENAME}" -print0 | /usr/bin/grep -qz . || echo "${i}"
}

find_file_not_in_other_directory_recursive() {
    local EXISTS_PATH="$1"
    local CHECK_PATH="$2"
    for i in ${EXISTS_PATH}/*/**; do
        [[ -d "${i}" ]] && continue
        local FILENAME=$(basename "${i}")
        filename_does_not_exist_in_directory_recursive "${CHECK_PATH}" "${FILENAME}"
   done
}

####################################
# Find common patterns
####################################

find_changed_here_x_days_ago() {
    local days_ago="$1"
    /usr/bin/find . -type f -newermt $(date --date="${days_ago} days ago" +%F) ! -newermt $(date +%F)
}


####################################
# Backups and Archives
####################################

backup_local_to_empty_location() {
    local from_path="$1"
    local to_path="$2"
    local today=$(date +%F)
    # -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
    # -s, --protect-args          no space-splitting; wildcard chars only
    # -q, --quiet                 suppress non-error messages
    # -v, --verbose               increase verbosity (Never go beyond 2 vv's because it can cause freezing)
    # --ignore-existing           skip updating files that exist on receiver
    set -x
    nice -n 19 rsync -avqs --ignore-existing --log-file="/tmp/rsync-${today}.log" "${from_path}" "${to_path}"  2>"/tmp/rsync-${today}.err"
    set +x
}

backup_local_with_continue() {
    local from_path="$1"
    local to_path="$2"
    local today=$(date +%F)
    # -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
    # -c, --checksum              skip based on checksum, not mod-time & size
    # -s, --protect-args          no space-splitting; wildcard chars only
    # -q, --quiet                 suppress non-error messages
    # -v, --verbose               increase verbosity (Never go beyond 2 vv's because it can cause freezing)
    # --partial                   keep partially transferred files
    # --append                    append data onto shorter files
    # --append-verify             --append w/old data in file checksum
    nice -n 19 rsync -acvqs --partial --append-verify --log-file="/tmp/rsync-${today}.log" "${from_path}" "${to_path}"  2>"/tmp
/rsync-${today}.err"
}


# --itemize-changes, -i
#     Requests a simple itemized list of the changes that are being made to each file, including attribute changes. This is exactly the same as specifying --out-format='%i %n%L'. If you repeat the option, unchanged files will also be output, but only if the receiving rsync is at least version 2.6.7 (you can use -vv with older versions of rsync, but that also turns on the output of other verbose messages).
#     The "%i" escape has a cryptic output that is 11 letters long. The general format is like the string YXcstpoguax, where Y is replaced by the type of update being done, X is replaced by the file-type, and the other letters represent attributes that may be output if they are being modified.
#
#     The update types that replace the Y are as follows:
#         A < means that a file is being transferred to the remote host (sent).
#         A > means that a file is being transferred to the local host (received).
#         A c means that a local change/creation is occurring for the item (such as the creation of a directory or the changing of a symlink, etc.).
#         A h means that the item is a hard link to another item (requires --hard-links).
#         A . means that the item is not being updated (though it might have attributes that are being modified).
#         A * means that the rest of the itemized-output area contains a message (e.g. "deleting").

#     The file-types that replace the X are: f for a file, a d for a directory, an L for a symlink, a D for a device, and a S for a special file (e.g. named sockets and fifos).

#     The other letters in the string indicate if some attributes of the file have changed, as follows:

#         "." -⁠ the attribute is unchanged.
#         "+" -⁠ the file is newly created.
#         " " -⁠ all the attributes are unchanged (all dots turn to spaces).
#         "?" -⁠ the change is unknown (when the remote rsync is old).
#         A letter indicates an attribute is being updated.

#     The attribute that is associated with each letter is as follows:

#         A c means either that a regular file has a different checksum (requires --checksum) or that a symlink, device, or special file has a changed value. Note that if you are sending files to an rsync prior to 3.0.1, this change flag will be present only for checksum-differing regular files.
#         A s means the size of a regular file is different and will be updated by the file transfer.
#         A t means the modification time is different and is being updated to the sender's value (requires --times). An alternate value of T means that the modification time will be set to the transfer time, which happens when a file/symlink/device is updated without --times and when a symlink is changed and the receiver can't set its time. (Note: when using an rsync 3.0.0 client, you might see the s flag combined with t instead of the proper T flag for this time-setting failure.)
#         A p means the permissions are different and are being updated to the sender's value (requires --perms).
#         An o means the owner is different and is being updated to the sender's value (requires --owner and super-user privileges).
#         A g means the group is different and is being updated to the sender's value (requires --group and the authority to set the group).
#         A u|n|b indicates the following information:
#             u means the access (use) time is different and is being updated to the sender's value (requires --atimes)
#             n means the create time (newness) is different and is being updated to the sender's value (requires --crtimes)
#             b means that both the access and create times are being updated
#         The a means that the ACL information is being changed.
#         The x means that the extended attribute information is being changed.

#     One other output is possible: when deleting files, the "%i" will output the string "*deleting" for each item that is being removed (assuming that you are talking to a recent enough rsync that it logs deletions instead of outputting them as a verbose message).
